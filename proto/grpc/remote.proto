syntax = "proto3";
package proto.grpc;

import "google/protobuf/timestamp.proto";
import "proto/audio/analysis/analysis.proto";

service RemoteController {
  // Connect and Disconnect to updates
  rpc Connect(ControllerConnectRequest) returns (stream ControllerUpdate) {}
  rpc Disconnect(ControllerDisconnectRequest) returns (Empty) {}

  // start and stop analyzing audio
  /* rpc StartAnalysis(StartAnalysisRequest) returns (Empty) {} */
  rpc AddAudioInputStream(AddAudioInputStreamRequest)
      returns (AudioInputStream) {}

  rpc AddAudioAnalyzer(AddAudioAnalyzerRequest) returns (AudioAnalyzer) {}

  rpc AddAudioOutputStream(AddAudioOutputStreamRequest)
      returns (AudioOutputStream) {}

  rpc SubscribeToAudioAnalyzer(SubscribeToAudioAnalyzerRequest)
      returns (InstanceSubscriptions) {}

  rpc ConnectLightsToAudioAnalyzer(ConnectLightsToAudioAnalyzerRequest)
      returns (InstanceSubscriptions) {}

  /* rpc RemoveAudioInputStream(RemoveAudioInputStreamRequest) returns
   * (AudioInputStream) {} */
  /* rpc AddAudioAnalyzer(AddAudioAnalyzerRequest) returns (AudioAnalyzer) {}
   */
  /* rpc RemoteAudioAnalyzer(AddAudioAnalyzerRequest) returns (AudioAnalyzer)
   * {}
   */

  // dont really need that if we do it internally in the connection method
  /* rpc NewInstanceId(NewInstanceIdRequest) returns (InstanceId) {} */

  // controller
  /* rpc QueryCurrentVisualization(QueryCurrentVisualizationRequest) */
  /*     returns (Visualization) {} */
  /* rpc RegisterVisualization(RegisterVisualizationRequest) returns (Empty)
   * {}
   */

  // the entire parameterization is happening on the client based on the
  // selected parameterizer but when one controls via the controller, the
  // changes should be live so we also have to upload the entire user input
  // includes: active visualization, active parameterizer, their user defined
  // options (which can be changed e.g. with a midi and then have to be
  // synced) maybe best if all the updates go to the backend and really just
  // the updates that come back trigger something in the viewer such that they
  // really have no shared state whatsoever
}

service RemoteViewer {
  // Connect and Disconnect to updates
  rpc Connect(ViewerConnectRequest) returns (stream ViewerUpdate) {}
  rpc Disconnect(ViewerDisconnectRequest) returns (Empty) {}

  /* rpc NewInstanceId(NewInstanceIdRequest) returns (InstanceId) {} */

  // change subscription
  rpc UpdateSubscription(UpdateSubscriptionRequest) returns (Empty) {}
}

/* enum AudioStreamKind { */
/*   INPUT = 0; */
/*   OUTPUT = 1; */
/* } */

/* message AudioStreamDescriptor { */
/*   AudioStreamKind kind = 1; */
/*   string device = 2; */
/*   string host = 3; */
/* } */
message AudioInputDescriptor {
  string backend = 1;
  string device = 2;
  string host = 3;
}

message AudioAnalyzerDescriptor {
  string name = 1;
  // todo: maybe in the future we also want to key by their parameters
  AudioInputDescriptor input = 10;
}

message AudioOutputDescriptor {
  string backend = 1;
  string device = 2;
  string host = 3;
  AudioInputDescriptor input = 10;
}

message AudioInputStream { AudioInputDescriptor descriptor = 1; }
message AudioAnalyzer { AudioAnalyzerDescriptor descriptor = 1; }
message AudioOutputStream { AudioOutputDescriptor descriptor = 1; }

message SubscribeToAudioAnalyzerRequest {
  // we assume the session is the controller session
  InstanceId instance_id = 1;
  AudioAnalyzerDescriptor audio_analyzer_descriptor = 10;
}

message LightStrip {
  uint32 num_lights = 1;
  uint32 pin = 2;
}

message Lights {
  string serial_port = 1;
  repeated LightStrip strips = 10;
}

message ConnectLightsToAudioAnalyzerRequest {
  Lights lights = 1;
  AudioAnalyzerDescriptor audio_analyzer_descriptor = 10;
}

message InstanceSubscriptions {}

message AddAudioInputStreamRequest {
  // todo: all the options about device etc.
}

message AddAudioAnalyzerRequest {
  // todo: all the audio analyzer options
  proto.audio.analysis.AudioAnalyzer analyzer = 1;
  AudioInputDescriptor input_descriptor = 10;
}

message AddAudioOutputStreamRequest {
  // todo: all the options about device etc.
  AudioInputDescriptor input_descriptor = 1;
}

/* message NewInstanceIdRequest {} */

message InstanceId { string id = 1; }
message SessionToken { string token = 1; }

message Visualization {}

message QueryCurrentVisualizationRequest {}

message RegisterVisualizationRequest {}

message Empty {}

message Heartbeat { uint64 seq = 1; }

message Assignment {
  SessionToken session_token = 1;
  InstanceId instance_id = 2;
}

message ViewerUpdate {
  oneof update {
    // todo: add status messages or notifications
    Heartbeat heartbeat = 1;
    Assignment assignment = 2;
    proto.audio.analysis.AudioAnalysisResult audio_analysis_result = 100;
  }
}

message ControllerUpdate {
  oneof update {
    // todo: add status messages or notifications
    Heartbeat heartbeat = 1;
  }
}

message DefaultAudioSource {
  // todo
}

message CustomAudioSource {
  // todo
}

message AudioSource {
  oneof source {
    DefaultAudioSource default = 1;
    CustomAudioSource custom = 2;
  }
}

message StartAnalysisRequest { AudioSource audio_source = 10; }

message UpdateSubscriptionRequest {
  AudioSource audio_source = 1;
  /* string topic = 1; */
}

message ControllerConnectRequest { InstanceId instance = 1; }

message ControllerDisconnectRequest {}

message ViewerConnectRequest { InstanceId instance = 1; }

message ViewerDisconnectRequest {}

/* message Result { */
/*   google.protobuf.Timestamp date = 2; */
/* } */
