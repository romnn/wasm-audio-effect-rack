syntax = "proto3";
package proto.grpc;

import "google/protobuf/timestamp.proto";
import "proto/audio/analysis/analysis.proto";

service RemoteController {
  // Connect and Disconnect to updates
  rpc Connect(ControllerConnectRequest) returns (stream ControllerUpdate) {}
  rpc Disconnect(ControllerDisconnectRequest) returns (Empty) {}

  // start and stop analyzing audio
  /* rpc StartAnalysis(StartAnalysisRequest) returns (Empty) {} */
  rpc AddAudioInputStream(AddAudioInputStreamRequest)
      returns (AudioInputStream) {}
  rpc AddAudioOutputStream(AddAudioOutputStreamRequest)
      returns (AudioOutputStream) {}
  /* rpc RemoveAudioInputStream(RemoveAudioInputStreamRequest) returns
   * (AudioInputStream) {} */
  /* rpc AddAudioAnalyzer(AddAudioAnalyzerRequest) returns (AudioAnalyzer) {} */
  /* rpc RemoteAudioAnalyzer(AddAudioAnalyzerRequest) returns (AudioAnalyzer) {}
   */

  // dont really need that if we do it internally in the connection method
  /* rpc NewInstanceId(NewInstanceIdRequest) returns (InstanceId) {} */

  // controller
  /* rpc QueryCurrentVisualization(QueryCurrentVisualizationRequest) */
  /*     returns (Visualization) {} */
  /* rpc RegisterVisualization(RegisterVisualizationRequest) returns (Empty) {}
   */

  // the entire parameterization is happening on the client based on the
  // selected parameterizer but when one controls via the controller, the
  // changes should be live so we also have to upload the entire user input
  // includes: active visualization, active parameterizer, their user defined
  // options (which can be changed e.g. with a midi and then have to be synced)
  // maybe best if all the updates go to the backend and really just the updates
  // that come back trigger something in the viewer such that they really have
  // no shared state whatsoever
}

service RemoteViewer {
  // Connect and Disconnect to updates
  rpc Connect(ViewerConnectRequest) returns (stream ViewerUpdate) {}
  rpc Disconnect(ViewerDisconnectRequest) returns (Empty) {}

  /* rpc NewInstanceId(NewInstanceIdRequest) returns (InstanceId) {} */

  // change subscription
  rpc UpdateSubscription(UpdateSubscriptionRequest) returns (Empty) {}
}

message AudioInputStream {}
message AudioOutputStream {}

message AddAudioInputStreamRequest {}
message AddAudioOutputStreamRequest {}

/* message NewInstanceIdRequest {} */

message InstanceId { string id = 1; }
message SessionToken { string token = 1; }

message Visualization {}

message QueryCurrentVisualizationRequest {}

message RegisterVisualizationRequest {}

message Empty {}

message Heartbeat { uint64 seq = 1; }

message Assignment {
  SessionToken session_token = 1;
  InstanceId instance_id = 2;
}

message ViewerUpdate {
  oneof update {
    // todo: add status messages or notifications
    Heartbeat heartbeat = 1;
    Assignment assignment = 2;
    proto.audio.analysis.AudioAnalysisResult audio_analysis_result = 100;
  }
}

message ControllerUpdate {
  oneof update {
    // todo: add status messages or notifications
    Heartbeat heartbeat = 1;
  }
}

message DefaultAudioSource {
  // todo
}

message CustomAudioSource {
  // todo
}

message AudioSource {
  oneof source {
    DefaultAudioSource default = 1;
    CustomAudioSource custom = 2;
  }
}

message StartAnalysisRequest { AudioSource audio_source = 10; }

message UpdateSubscriptionRequest {
  AudioSource audio_source = 1;
  /* string topic = 1; */
}

message ControllerConnectRequest { InstanceId instance = 1; }

message ControllerDisconnectRequest {}

message ViewerConnectRequest { InstanceId instance = 1; }

message ViewerDisconnectRequest {}

/* message Result { */
/*   google.protobuf.Timestamp date = 2; */
/* } */
